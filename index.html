<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Myco ‚Äî Cycle + TfL Planner (Google + Serverless)</title>
  <link rel="manifest" href="/manifest.webmanifest">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    :root {
      --bg-1: 250 250 252;
      --brand: 99 102 241;
      /* Indigo */
      --accent: 16 185 129;
      /* Emerald */
      --hot: 244 63 94;
      /* Rose */
      --text-1: 15 23 42;
    }

    html,
    body {
      height: 100%;
    }

    body {
      font-family: 'Inter', system-ui, sans-serif;
      background: #fafafa;
      color: rgb(var(--text-1));
    }

    #map {
      height: 100%;
      min-height: 480px;
      border-radius: 1.5rem;
      overflow: hidden;
      box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.05);
    }

    @media (max-width: 640px) {
      #map {
        height: 60vh;
        min-height: 60vh;
        border-radius: 1rem;
      }
    }

    .blob-wrap {
      position: fixed;
      inset: 0;
      z-index: -1;
      filter: blur(60px);
      opacity: 0.6;
      pointer-events: none;
      overflow: hidden;
    }

    .blob {
      position: absolute;
      border-radius: 50%;
      opacity: 0.4;
      mix-blend-mode: multiply;
      animation: float 20s infinite;
    }

    .b1 {
      width: 50vw;
      height: 50vw;
      left: -10vw;
      top: -10vw;
      background: radial-gradient(circle at center, rgba(var(--brand), 0.8), transparent 70%);
      animation-delay: 0s;
    }

    .b2 {
      width: 45vw;
      height: 45vw;
      right: -5vw;
      top: 10vh;
      background: radial-gradient(circle at center, rgba(var(--accent), 0.8), transparent 70%);
      animation-delay: -5s;
    }

    .b3 {
      width: 55vw;
      height: 55vw;
      left: 20%;
      bottom: -10%;
      background: radial-gradient(circle at center, rgba(var(--hot), 0.8), transparent 70%);
      animation-delay: -10s;
    }

    @keyframes float {

      0%,
      100% {
        transform: translate(0, 0)
      }

      33% {
        transform: translate(30px, -50px)
      }

      66% {
        transform: translate(-20px, 20px)
      }
    }

    .glass {
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      background: rgba(255, 255, 255, 0.75);
      border: 1px solid rgba(255, 255, 255, 0.8);
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.02), 0 2px 4px -1px rgba(0, 0, 0, 0.02);
    }

    .card {
      background: rgba(255, 255, 255, 0.85);
      backdrop-filter: blur(16px);
      border: 1px solid rgba(255, 255, 255, 0.9);
      border-radius: 1.5rem;
      box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.03);
    }

    .header-card {
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(12px);
      border-bottom: 1px solid rgba(0, 0, 0, 0.05);
    }

    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: .5rem;
      border-radius: 1rem;
      padding: .75rem 1.25rem;
      font-weight: 600;
      transition: all .2s cubic-bezier(0.4, 0, 0.2, 1);
      cursor: pointer;
    }

    .btn:active {
      transform: scale(0.96);
    }

    .btn-primary {
      background: linear-gradient(135deg, rgb(var(--brand)) 0%, rgb(139, 92, 246) 100%);
      color: #fff;
      box-shadow: 0 4px 6px -1px rgba(var(--brand), 0.25);
    }

    .btn-primary:hover {
      filter: brightness(1.1);
      box-shadow: 0 10px 15px -3px rgba(var(--brand), 0.3);
    }

    .btn-ghost {
      background: white;
      border: 1px solid #e2e8f0;
      color: #475569;
    }

    .btn-ghost:hover {
      background: #f8fafc;
      border-color: #cbd5e1;
    }

    .field {
      width: 100%;
      border-radius: 1rem;
      border: 1px solid #e2e8f0;
      padding: .75rem 1rem;
      outline: none;
      transition: .2s;
      background: white;
    }

    .field:focus {
      border-color: rgb(var(--brand));
      box-shadow: 0 0 0 4px rgba(var(--brand), 0.1);
    }

    .section-title {
      display: block;
      font-size: .7rem;
      font-weight: 700;
      color: #64748b;
      text-transform: uppercase;
      letter-spacing: .05em;
      margin-bottom: 0.25rem;
    }

    .chip {
      display: inline-flex;
      align-items: center;
      gap: .3rem;
      padding: .25rem .6rem;
      border-radius: 999px;
      font-weight: 600;
      font-size: .75rem;
      background: #f1f5f9;
      color: #475569;
    }

    .value-badge {
      background: rgb(var(--brand));
      color: white;
    }

    .slider {
      -webkit-appearance: none;
      width: 100%;
      height: 6px;
      background: #e2e8f0;
      border-radius: 999px;
      outline: none;
    }

    .slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 22px;
      height: 22px;
      border-radius: 50%;
      background: white;
      border: 2px solid rgb(var(--brand));
      cursor: pointer;
      box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1);
      transition: transform .1s;
    }

    .slider::-webkit-slider-thumb:hover {
      transform: scale(1.1);
    }

    .corner-mark {
      position: fixed;
      right: 14px;
      bottom: 14px;
      width: 64px;
      height: 64px;
      opacity: .2;
      pointer-events: none;
    }
  </style>
  <script src="stations.js"></script>
  rgba(var(--brand), .9), rgba(var(--brand), 0));
  }

  .b2 {
  width: 32vmax;
  height: 32vmax;
  right: 8vmax;
  top: -4vmax;
  background: radial-gradient(closest-side,
  rgba(var(--accent), .9), rgba(var(--accent), 0));
  }

  .b3 {
  width: 36vmax;
  height: 36vmax;
  left: 20vmax;
  top: 22vmax;
  background: radial-gradient(closest-side,
  rgba(var(--hot), .9), rgba(var(--hot), 0));
  }

  .glass {
  backdrop-filter: blur(8px);
  background: rgba(255, 255, 255, .7);
  border-radius: 2rem;
  }

  .btn {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: .5rem;
  border-radius: 999px;
  padding: .75rem 1.25rem;
  font-size: 1rem;
  font-weight: 500;
  transition: .15s;
  box-shadow: 0 1px 2px rgba(0, 0, 0, .06);
  }

  .btn-primary {
  background: linear-gradient(135deg, rgb(var(--brand)) 0%, rgb(var(--accent)) 100%);
  color: #fff;
  }

  .btn-ghost {
  border: 1px solid rgba(255, 255, 255, .6);
  background: rgba(255, 255, 255, .65);
  }

  .card {
  border-radius: 1.5rem;
  border: 1px solid rgba(255, 255, 255, .6);
  background: rgba(255, 255, 255, .7);
  box-shadow: 0 8px 24px rgba(0, 0, 0, .08);
  }

  .header-card {
  background: #fff;
  border: 1px solid rgba(226, 232, 240, .8);
  }

  .field {
  width: 100%;
  border-radius: 999px;
  border: 1px solid rgba(148, 163, 184, .6);
  padding: .75rem 1.25rem;
  font-size: 1rem;
  outline: none;
  box-shadow: 0 0 0 0 rgba(139, 92, 246, .3);
  }

  .field:focus {
  box-shadow: 0 0 0 6px rgba(139, 92, 246, .15);
  }

  .section-title {
  font-size: .75rem;
  font-weight: 600;
  color: #334155;
  text-transform: uppercase;
  letter-spacing: .06em;
  }

  .chip {
  display: inline-flex;
  align-items: center;
  gap: .4rem;
  font-size: .75rem;
  padding: .25rem .6rem;
  border-radius: 999px;
  border: 1px solid rgb(255 255 255 / .8);
  background: rgb(255 255 255 / .8);
  }

  .slider {
  -webkit-appearance: none;
  width: 100%;
  height: 0.75rem;
  background: rgba(255, 255, 255, .8);
  border-radius:
  999px;
  outline: none;
  border: 1px solid rgba(148, 163, 184, .35);
  }

  .slider::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 1.25rem;
  height: 1.25rem;
  border-radius: 999px;
  background: linear-gradient(135deg, rgb(var(--brand)) 0%, rgb(var(--accent)) 100%);
  border: 2px solid white;
  box-shadow: 0 4px 10px rgba(0, 0, 0, .15);
  cursor: pointer;
  }

  .slider::-moz-range-thumb {
  width: 1.25rem;
  height: 1.25rem;
  border-radius: 999px;
  background: linear-gradient(135deg,
  rgb(var(--brand)) 0%, rgb(var(--accent)) 100%);
  border: 2px solid white;
  box-shadow: 0 4px 10px rgba(0, 0, 0, .15);
  cursor:
  pointer;
  }

  .corner-mark {
  position: fixed;
  right: 14px;
  bottom: 14px;
  width: 84px;
  height: 84px;
  opacity: .35;
  pointer-events:
  none;
  filter: drop-shadow(0 6px 12px rgba(0, 0, 0, .12));
  }
  </style>
</head>

<body>
  <!-- Blobby bg -->
  <div class="blob-wrap" aria-hidden="true">
    <div class="blob b1"></div>
    <div class="blob b2"></div>
    <div class="blob b3"></div>
  </div>

  <!-- Header -->
  <header class="px-4 sm:px-6 py-3 sticky top-0 z-40">
    <div class="card header-card px-4 py-3 flex items-center gap-3">
      <!-- Myco logo (your new artwork) -->
      <div class="h-12 w-12 rounded-full overflow-hidden shadow-md ring-2 ring-white/60">
        <img src="/icons/icon-192.png" alt="Myco" class="h-full w-full object-cover" />
      </div>
      <h1 class="text-xl font-semibold text-slate-800">Myco</h1>
      <span class="ml-1 text-xs px-2 py-0.5 rounded-full bg-white/70 border border-white/80 text-slate-600">Google +
        Serverless</span>
      <div class="ml-auto text-xs text-slate-600">Keys secured on server ‚Ä¢ Referrer-locked render key</div>
    </div>
  </header>

  <!-- Main -->
  <main class="max-w-7xl mx-auto w-full gap-4 grid grid-cols-1 lg:grid-cols-[430px_1fr] p-3 sm:p-5">
    <section class="card p-4 space-y-4">
      <div class="grid sm:grid-cols-2 gap-3">
        <div>
          <label class="section-title">Origin</label>
          <div class="flex gap-2">
            <input id="origin" class="field flex-1" placeholder="Address or place" />
            <button id="useLoc" class="btn btn-ghost shrink-0" title="Use my location">üìç</button>
          </div>
        </div>
        <div>
          <label class="section-title">Destination</label>
          <input id="destination" class="field" placeholder="Where to?" />
        </div>
      </div>

      <div class="grid grid-cols-1 gap-4">
        <div>
          <div class="flex items-center justify-between">
            <label class="section-title">Max cycling (minutes)</label>
            <span class="value-badge chip"><span id="cycleVal">10</span> min</span>
          </div>
          <input id="cycleTime" type="range" min="5" max="60" step="5" value="10" class="slider mt-1" />
          <p class="text-xs text-slate-600 mt-1">Cycle segments assume rentable e-bikes cruising at ~20&nbsp;km/h.</p>
        </div>
      </div>

      <div class="flex items-start gap-3 p-3 rounded-full border border-white/60 glass">
        <input id="strictCap" type="checkbox" class="h-5 w-5 rounded mt-0.5" />
        <div class="text-sm">Strict cycling cap ‚Äî ignore bike-only if over the cap.</div>
      </div>

      <div class="grid grid-cols-2 gap-2">
        <button id="planBtn" class="btn btn-primary">üöÄ Find route</button>
        <button id="clearBtn" class="btn btn-ghost">Clear</button>
      </div>

      <div id="msg" class="text-sm text-slate-700"></div>
    </section>

    <section class="grid grid-rows-[minmax(420px,1fr)_auto] gap-3">
      <div id="map" class="card"></div>
      <div class="card p-4">
        <div class="flex items-center justify-between">
          <h3 class="text-sm font-semibold mb-2">Best route</h3>
          <div id="fare" class="text-sm"></div>
        </div>
        <div id="summary" class="text-sm"></div>
      </div>
    </section>
  </main>

  <!-- Corner watermark -->
  <svg class="corner-mark" viewBox="0 0 200 200" aria-hidden="true">
    <g stroke="#8B5CF6" stroke-width="2" fill="none" opacity="0.55">
      <path d="M100 190 C95 150 95 140 70 120 M100 190 C105 150 110 140 130 120" />
      <path d="M70 120 C60 110 55 95 45 85 M70 120 C75 95 80 85 90 75" />
      <path d="M130 120 C140 105 150 95 165 90 M130 120 C122 98 118 90 110 80" />
      <circle cx="100" cy="190" r="5" fill="#10B981" stroke="white" stroke-width="3" />
      <circle cx="70" cy="120" r="4" fill="#10B981" stroke="white" stroke-width="2" />
      <circle cx="130" cy="120" r="4" fill="#10B981" stroke="white" stroke-width="2" />
      <circle cx="45" cy="85" r="3" fill="#10B981" stroke="white" stroke-width="2" />
      <circle cx="90" cy="75" r="3" fill="#10B981" stroke="white" stroke-width="2" />
      <circle cx="165" cy="90" r="3" fill="#10B981" stroke="white" stroke-width="2" />
      <circle cx="110" cy="80" r="3" fill="#10B981" stroke="white" stroke-width="2" />
    </g>
  </svg>

  <script>
    // ===== Globals =====
    let map;
    let originPlace = null, destPlace = null;
    let originMarker = null, destMarker = null;
    let polylines = [], stationMarkers = [];

    const el = (id) => document.getElementById(id);
    const msg = (t) => el('msg').innerHTML = t || '';

    const GOOGLE_BASE_CYCLING_SPEED_KMH = 16; // Google cycling directions baseline
    const ASSUMED_E_BIKE_SPEED_KMH = 20; // rentable e-bike assumption
    const BIKE_TIME_MODIFIER = GOOGLE_BASE_CYCLING_SPEED_KMH / ASSUMED_E_BIKE_SPEED_KMH;

    const LINE_COLOURS = {
      'Bakerloo': '#B36305', 'Central': '#E32017', 'Circle': '#FFD300', 'District': '#00782A', 'Hammersmith & City': '#F3A9BB', 'Jubilee': '#A0A5A9', 'Metropolitan': '#9B0056', 'Northern': '#000000', 'Piccadilly': '#003688', 'Victoria': '#0098D4', 'Waterloo & City': '#95CDBA', 'DLR': '#00A4A7', 'London Overground': '#EE7C0E', 'Elizabeth line': '#6950A1', 'Tram': '#009999', 'Bus': '#CC0000'
    };

    // Slider live badge
    (function () { const s = el('cycleTime'), o = el('cycleVal'); const sync = () => o.textContent = s.value; s.addEventListener('input', sync); sync(); })();

    // ===== Bootstrap: load key then Maps JS (with places, geometry, marker) =====
    (async function bootstrap() {
      try {
        const env = await fetch('/api/env').then(r => r.json()).catch(() => ({ mapsJsKey: null }));
        const key = env.mapsJsKey || null;
        if (!key) { msg('Maps key not configured. Set NEXT_PUBLIC_MAPS_JS_KEY in Vercel and redeploy.'); return; }
        await loadGoogleMaps(key);
        initAfterMapsLoad();
      } catch (e) { console.error(e); msg('Failed to load Maps: ' + e.message); }
    })();

    function loadGoogleMaps(key) {
      return new Promise((resolve, reject) => {
        const s = document.createElement('script');
        // include marker library for AdvancedMarkerElement
        s.src = `https://maps.googleapis.com/maps/api/js?key=${key}&libraries=places,geometry,marker`;
        s.async = true; s.defer = true;
        s.onload = resolve; s.onerror = () => reject(new Error('Maps SDK load error'));
        document.head.appendChild(s);
      });
    }

    function initAfterMapsLoad() {
      map = new google.maps.Map(document.getElementById('map'), {
        center: { lat: 51.5074, lng: -0.1278 }, zoom: 11, mapTypeControl: false, streetViewControl: false, fullscreenControl: false,
        styles: [{ featureType: 'poi', stylers: [{ visibility: 'off' }] }]
      });

      const originInput = el('origin');
      const destInput = el('destination');
      const originAC = new google.maps.places.Autocomplete(originInput, { fields: ["geometry", "name", "formatted_address"] });
      const destAC = new google.maps.places.Autocomplete(destInput, { fields: ["geometry", "name", "formatted_address"] });

      originAC.addListener('place_changed', () => {
        originPlace = originAC.getPlace();
        if (originPlace?.geometry?.location) { setMarker('origin', originPlace.geometry.location); map.panTo(originPlace.geometry.location); map.setZoom(13); }
      });
      destAC.addListener('place_changed', () => {
        destPlace = destAC.getPlace();
        if (destPlace?.geometry?.location) { setMarker('dest', destPlace.geometry.location); }
      });

      el('useLoc').addEventListener('click', useGeolocation);
      el('planBtn').addEventListener('click', planBestRoute);
      el('clearBtn').addEventListener('click', clearAll);
    }


    // ===== Classic markers (no Map ID needed) =====
    function iconCircle(color, scale, stroke = 2) {
      return {
        path: google.maps.SymbolPath.CIRCLE,
        scale,
        fillColor: color,
        fillOpacity: 1,
        strokeWeight: stroke,
        strokeColor: '#ffffff'
      };
    }

    function setMarker(kind, latLng) {
      const color = kind === 'origin' ? '#34d399' : '#fbbf24';
      if (kind === 'origin') {
        if (originMarker) originMarker.setMap(null);
        originMarker = new google.maps.Marker({ map, position: latLng, icon: iconCircle(color, 10, 3), title: kind });
      } else {
        if (destMarker) destMarker.setMap(null);
        destMarker = new google.maps.Marker({ map, position: latLng, icon: iconCircle(color, 10, 3), title: kind });
      }
    }

    function addStationMarker(position, isOriginSide) {
      const color = isOriginSide ? '#06b6d4' : '#f59e0b';
      const m = new google.maps.Marker({ map, position, icon: iconCircle(color, 6, 2) });
      stationMarkers.push(m);
    }

    // ===== Geolocation helper =====
    function useGeolocation() {
      if (!navigator.geolocation) { msg('Geolocation not supported.'); return; }
      navigator.geolocation.getCurrentPosition((pos) => {
        const ll = { lat: pos.coords.latitude, lng: pos.coords.longitude };
        originPlace = { geometry: { location: new google.maps.LatLng(ll) }, name: 'My location', formatted_address: 'My location' };
        el('origin').value = 'My location';
        setMarker('origin', ll); map.setZoom(14); map.panTo(ll);
      }, (err) => msg('Failed to get location: ' + err.message), { enableHighAccuracy: true, timeout: 10000 });
    }

    // ===== Clear =====
    function clearAll() {
      originPlace = destPlace = null; el('origin').value = ''; el('destination').value = '';
      if (originMarker) originMarker.map = null; if (destMarker) destMarker.map = null;
      originMarker = destMarker = null;
      polylines.forEach(l => l.setMap(null)); polylines = [];
      stationMarkers.forEach(m => m.map = null); stationMarkers = [];
      el('summary').innerHTML = ''; el('fare').innerHTML = ''; msg('');
    }

    // ===== Serverless fetchers =====
    async function fetchDirections({ origin, destination, mode, transitModes }) {
      const params = new URLSearchParams({ origin, destination, mode });
      if (mode === 'TRANSIT' && transitModes?.length) params.set('transitModes', transitModes.join('|')); // pipe-separated
      const r = await fetch(`/api/directions?${params.toString()}`);
      const json = await r.json();
      if (!r.ok || (json.status && json.status !== 'OK' && json.status !== 'ZERO_RESULTS')) {
        const em = json.error_message || json.status || 'Directions error';
        throw new Error(em);
      }
      return json; // Google Directions REST JSON
    }

    async function fetchNearbyStations({ lat, lng, radius }) {
      // subway + train (tube/rail)
      const q1 = new URLSearchParams({ lat, lng, radius: String(radius), type: 'subway_station' }).toString();
      const q2 = new URLSearchParams({ lat, lng, radius: String(radius), type: 'train_station' }).toString();
      const [aRes, bRes] = await Promise.all([fetch(`/api/places-nearby?${q1}`), fetch(`/api/places-nearby?${q2}`)]);
      const a = await aRes.json(); const b = await bRes.json();
      if ((!aRes.ok || (a.status && a.status !== 'OK' && a.status !== 'ZERO_RESULTS')) &&
        (!bRes.ok || (b.status && b.status !== 'OK' && b.status !== 'ZERO_RESULTS'))) {
        const em = a?.error_message || b?.error_message || 'Places nearby error';
        throw new Error(em);
      }
      const take = (json) => (json.results || []).map(p => ({
        id: p.place_id, name: p.name,
        location: new google.maps.LatLng(p.geometry.location.lat, p.geometry.location.lng)
      }));
      const all = [...take(a), ...take(b)];
      const dedup = Object.values(all.reduce((acc, s) => { acc[s.id] = s; return acc; }, {}));
      const base = new google.maps.LatLng(lat, lng);
      dedup.sort((x, y) => google.maps.geometry.spherical.computeDistanceBetween(x.location, base) - google.maps.geometry.spherical.computeDistanceBetween(y.location, base));
      return dedup.slice(0, 6);
    }

    // ===== Planner =====
    async function planBestRoute() {
      if (!originPlace?.geometry?.location || !destPlace?.geometry?.location) { msg('Please set both origin and destination.'); return; }

      msg('Planning‚Ä¶');
      polylines.forEach(l => l.setMap(null)); polylines = []; stationMarkers.forEach(m => m.map = null); stationMarkers = []; el('fare').innerHTML = '';

      const maxCycleMin = parseInt(el('cycleTime').value, 10);
      const strictCap = el('strictCap').checked;
      const bikeSpeedKmh = ASSUMED_E_BIKE_SPEED_KMH;
      const maxCycleMeters = Math.round((bikeSpeedKmh * 1000 / 3600) * (maxCycleMin * 60));

      const originLL = originPlace.geometry.location; const destLL = destPlace.geometry.location;

      // Local lookup instead of API
      const originStations = findStations({ lat: originLL.lat(), lng: originLL.lng(), radiusMeters: maxCycleMeters });
      const destStations = findStations({ lat: destLL.lat(), lng: destLL.lng(), radiusMeters: maxCycleMeters });


      // draw stations
      // draw stations
      originStations.forEach((s) => addStationMarker({ lat: s.lat, lng: s.lng }, true));
      destStations.forEach((s) => addStationMarker({ lat: s.lat, lng: s.lng }, false));

      const candidates = [];
      const str = (ll) => `${ll.lat()},${ll.lng()}`;

      // Bike-only
      try {
        const bikeOD = await fetchDirections({ origin: str(originLL), destination: str(destLL), mode: 'BICYCLING' });
        const tBike = adjustCycleDuration(sumDurationREST(bikeOD));
        const allowBikeOnly = !strictCap || (tBike <= maxCycleMin * 60);
        if (allowBikeOnly) candidates.push({ kind: 'bike-only', totalSec: tBike, segments: [{ mode: 'BICYCLING', res: bikeOD }] });
      } catch (e) { console.warn('Bike-only failed:', e.message); }

      // Transit-only
      try {
        const trOD = await fetchDirections({ origin: str(originLL), destination: str(destLL), mode: 'TRANSIT', transitModes: ['SUBWAY', 'TRAIN', 'TRAM', 'BUS'] });
        if (sumDurationREST(trOD) < Infinity) {
          candidates.push({ kind: 'transit-only', totalSec: sumDurationREST(trOD), segments: [{ mode: 'TRANSIT', res: trOD }] });
        }
      } catch (e) { console.warn('Transit-only failed:', e.message); }

      // Combos
      // Combos - Smart Heuristic
      const pairs = [];
      for (const a of originStations) {
        for (const b of destStations) {
          if (a.name === b.name) continue; // Same station
          let score = 0;
          // Heuristic: Prefer shared lines (1000pts), penalize by distance
          const commonLine = a.lines.find(l => b.lines.includes(l));
          if (commonLine) score += 1000;
          score -= (a.dist + b.dist);
          pairs.push({ a, b, score, commonLine });
        }
      }
      // Top 5 only
      pairs.sort((x, y) => y.score - x.score);
      const topPairs = pairs.slice(0, 5);

      for (const p of topPairs) {
        const { a, b } = p;
        try {
          const seg1 = await fetchDirections({ origin: str(originLL), destination: `${a.lat},${a.lng}`, mode: 'BICYCLING' });
          const seg2 = await fetchDirections({ origin: `${a.lat},${a.lng}`, destination: `${b.lat},${b.lng}`, mode: 'TRANSIT', transitModes: ['SUBWAY', 'TRAIN', 'TRAM', 'BUS'] });
          const seg3 = await fetchDirections({ origin: `${b.lat},${b.lng}`, destination: str(destLL), mode: 'BICYCLING' });
          const t1 = adjustCycleDuration(sumDurationREST(seg1)), t2 = sumDurationREST(seg2), t3 = adjustCycleDuration(sumDurationREST(seg3));

          if (t1 > maxCycleMin * 60 || t3 > maxCycleMin * 60) continue;
          candidates.push({ kind: 'combo', totalSec: t1 + t2 + t3, parts: { a, b }, segments: [{ mode: 'BICYCLING', res: seg1 }, { mode: 'TRANSIT', res: seg2 }, { mode: 'BICYCLING', res: seg3 }] });
        } catch (e) { /* skip bad pair */ }
      }

      if (!candidates.length) {
        msg('No routes found. Check billing on your GCP project and that GOOGLE_SERVER_KEY allows Directions & Places.');
        return;
      }
      candidates.sort((x, y) => x.totalSec - y.totalSec);
      const best = candidates[0];
      const cycleOnly = candidates.find(c => c.kind === 'bike-only');
      renderSolution(best, (cycleOnly && cycleOnly !== best) ? cycleOnly : null);
      msg('');
    }

    function adjustCycleDuration(seconds) {
      if (!Number.isFinite(seconds)) return seconds;
      return Math.round(seconds * BIKE_TIME_MODIFIER);
    }

    function sumDurationREST(json) {
      try {
        if (json.status && json.status !== 'OK') return Infinity;
        const legs = json.routes?.[0]?.legs || [];
        return legs.reduce((acc, leg) => acc + (leg.duration?.value || 0), 0);
      } catch (e) {
        console.warn('sumDurationREST error', e);
        return Infinity;
      }
    }

    function renderSolution(sol, compareCycle) {
      const summary = el('summary'); summary.innerHTML = ''; el('fare').innerHTML = '';
      const fmt = (s) => { const m = Math.round(s / 60); return m < 60 ? `${m} min` : `${Math.floor(m / 60)}h ${m % 60}m`; };

      // draw polylines
      for (const seg of sol.segments) {
        const route = seg.res.routes[0];
        const path = google.maps.geometry.encoding.decodePath(route.overview_polyline.points);
        const color = seg.mode === 'BICYCLING' ? '#10b981' : '#6366f1';
        const poly = new google.maps.Polyline({ path, strokeColor: color, strokeOpacity: .95, strokeWeight: 7, map });
        polylines.push(poly);
      }
      const bounds = new google.maps.LatLngBounds(); polylines.forEach(pl => pl.getPath().forEach(pt => bounds.extend(pt))); if (!bounds.isEmpty()) map.fitBounds(bounds, 64);

      // title
      const title = document.createElement('div'); title.className = 'mb-2'; title.innerHTML = `<div class="text-base font-semibold text-slate-800">${labelForKind(sol)}</div><div class="text-sm text-slate-700">Total time: <span class="font-semibold">${fmt(sol.totalSec)}</span></div>`;
      summary.appendChild(title);

      const list = document.createElement('ol'); list.className = 'list-decimal pl-5 space-y-3';
      if (sol.kind === 'combo') {
        const li1 = document.createElement('li'); li1.innerHTML = `<div class="font-medium">Cycle ‚Äî ${fmt(adjustCycleDuration(sumDurationREST(sol.segments[0].res)))}</div><div class="text-xs text-slate-600">to <b>${sol.parts.a.name}</b></div>`; list.appendChild(li1);
        const li2 = document.createElement('li'); li2.innerHTML = `<div class="font-medium">TfL Transit ‚Äî ${fmt(sumDurationREST(sol.segments[1].res))}</div>`; list.appendChild(li2);
        const li3 = document.createElement('li'); li3.innerHTML = `<div class="font-medium">Cycle ‚Äî ${fmt(adjustCycleDuration(sumDurationREST(sol.segments[2].res)))}</div><div class="text-xs text-slate-600">from <b>${sol.parts.b.name}</b> to destination</div>`; list.appendChild(li3);
      } else if (sol.kind === 'bike-only') {
        const li = document.createElement('li'); li.innerHTML = `<div class="font-medium">Cycle ‚Äî ${fmt(sol.totalSec)}</div>`; list.appendChild(li);
      } else if (sol.kind === 'transit-only') {
        const li = document.createElement('li'); li.innerHTML = `<div class="font-medium">TfL Transit ‚Äî ${fmt(sol.totalSec)}</div>`; list.appendChild(li);
      }
      summary.appendChild(list);

      // transit details + transfers + fare
      const transitDetails = []; const transfers = []; let lastLine = null, lastArrStop = null; let shownFareText = null;
      for (const seg of sol.segments) {
        if (seg.mode === 'BICYCLING') continue;
        const route = seg.res.routes[0];
        if (!shownFareText && route.fare?.text) shownFareText = route.fare.text;
        for (const leg of route.legs) {
          for (const step of leg.steps) {
            const td = step.transit_details; if (!td) continue;
            const vehicle = td.line?.vehicle?.type || '';
            const rawLine = td.line?.short_name || td.line?.name || vehicle || 'Transit';
            const lineName = normaliseLineName(rawLine, vehicle);
            const color = LINE_COLOURS[lineName] || '#334155';
            const dep = td.departure_stop?.name || ''; const arr = td.arrival_stop?.name || '';
            const dir = td.headsign ? `towards ${td.headsign}` : '';
            const stops = (typeof td.num_stops === 'number') ? ` ‚Ä¢ ${td.num_stops} stops` : '';
            if (lastLine && lastLine !== lineName && lastArrStop) { transfers.push({ at: lastArrStop, from: lastLine, to: lineName }); }
            lastLine = lineName; lastArrStop = arr || dep || lastArrStop;
            transitDetails.push({ html: `${badge(lineName, color)} <b>${dep}</b> ‚Üí <b>${arr}</b> <span class='text-slate-600'>${dir}</span>${stops}` });
          }
        }
      }

      if (shownFareText) { el('fare').innerHTML = `<span class="chip">üí∑ ${shownFareText}</span>`; }

      if (transitDetails.length) {
        const block = document.createElement('div'); block.className = 'mt-3 p-3 rounded-[1.25rem] bg-white/70 border border-white/80';
        const t = document.createElement('div'); t.className = 'text-sm font-semibold text-slate-800'; t.textContent = 'Detailed TfL instructions'; block.appendChild(t);
        const ul = document.createElement('ul'); ul.className = 'text-sm text-slate-800 list-disc pl-5 space-y-1 mt-1';
        transitDetails.forEach(td => { const li = document.createElement('li'); li.innerHTML = td.html; ul.appendChild(li); });
        block.appendChild(ul);
        if (transfers.length) {
          const row = document.createElement('div'); row.className = 'mt-3 flex flex-wrap gap-2 items-center';
          row.innerHTML = `<span class="text-xs font-semibold text-slate-700">Transfers:</span> ` + transfers.map(tb => `${badge(tb.from, LINE_COLOURS[tb.from] || '#334155')} ‚Üí ${badge(tb.to, LINE_COLOURS[tb.to] || '#334155')} <span class="text-slate-600">@ ${tb.at}</span>`).join(' ');
          block.appendChild(row);
        }
        summary.appendChild(block);
      }

      if (compareCycle && compareCycle.kind === 'bike-only' && sol.kind !== 'bike-only') {
        const block = document.createElement('div'); block.className = 'mt-4 p-4 rounded-[1.25rem] bg-white/70 border border-white/80';
        const head = document.createElement('div'); head.className = 'text-sm font-semibold text-slate-800';
        head.textContent = 'Cycle-only comparison'; block.appendChild(head);

        const total = document.createElement('div'); total.className = 'text-sm text-slate-700 mt-1';
        total.innerHTML = `Total time: <span class="font-semibold">${fmt(compareCycle.totalSec)}</span>`;
        block.appendChild(total);

        const diffSec = compareCycle.totalSec - sol.totalSec;
        const diffRow = document.createElement('div'); diffRow.className = 'text-xs text-slate-600 mt-1';
        const diffLabel = diffSec > 0 ? `+${fmt(diffSec)} slower than best option` : diffSec < 0 ? `-${fmt(-diffSec)} faster than best option` : 'Matches best option time';
        diffRow.textContent = diffLabel; block.appendChild(diffRow);

        const detail = document.createElement('div'); detail.className = 'text-sm text-slate-800 mt-2';
        detail.innerHTML = `<span class="font-medium">Cycle</span> ‚Äî ${fmt(adjustCycleDuration(sumDurationREST(compareCycle.segments[0].res)))}`;
        block.appendChild(detail);

        summary.appendChild(block);
      }
    }

    function normaliseLineName(raw, vehicle) {
      const r = String(raw || '').trim();
      if (/overground/i.test(r)) return 'London Overground';
      if (/elizabeth/i.test(r)) return 'Elizabeth line';
      if (/dlr/i.test(r)) return 'DLR';
      if (/bakerloo/i.test(r)) return 'Bakerloo';
      if (/central/i.test(r)) return 'Central';
      if (/circle/i.test(r)) return 'Circle';
      if (/district/i.test(r)) return 'District';
      if (/hammersmith/i.test(r)) return 'Hammersmith & City';
      if (/jubilee/i.test(r)) return 'Jubilee';
      if (/metropolitan/i.test(r)) return 'Metropolitan';
      if (/northern/i.test(r)) return 'Northern';
      if (/piccadilly/i.test(r)) return 'Piccadilly';
      if (/victoria/i.test(r)) return 'Victoria';
      if (/waterloo/i.test(r)) return 'Waterloo & City';
      if (/tram/i.test(r)) return 'Tram';
      if (/bus/i.test(vehicle || r)) return 'Bus';
      return r;
    }
    function badge(label, color) { return `<span class="chip" style="border-color:${color}; background:${color}1a; color:${color}">${label}</span>`; }
    function labelForKind(sol) {
      switch (sol?.kind) {
        case 'combo': {
          const from = sol?.parts?.a?.name || 'origin';
          const to = sol?.parts?.b?.name || 'destination';
          return `Cycle + TfL via ${from} ‚Üí ${to}`;
        }
        case 'bike-only':
          return 'Cycle only';
        case 'transit-only':
          return 'TfL Transit only';
        default:
          return 'Best route';
      }
    }

    // ===== Optional tiny debug badge (remove if you like) =====
    (async function diag() {
      const box = document.createElement('div');
      box.style.position = 'fixed'; box.style.right = '8px'; box.style.bottom = '8px';
      box.style.background = 'rgba(255,255,255,.8)'; box.style.border = '1px solid rgba(148,163,184,.35)';
      box.style.borderRadius = '12px'; box.style.padding = '6px 8px'; box.style.font = '12px/1.2 Inter, sans-serif'; box.style.zIndex = 9999;
      box.innerHTML = 'Diag: <span id="d-maps">Maps?</span> ‚Ä¢ <span id="d-env">Env?</span> ‚Ä¢ <span id="d-pl">Places?</span> ‚Ä¢ <span id="d-dir">Dir?</span>';
      document.body.appendChild(box);
      const ok = (id, good, txt) => { const el = document.getElementById(id); el.textContent = txt; el.style.color = good ? '#16a34a' : '#dc2626'; };
      try { const env = await fetch('/api/env').then(r => r.json()); ok('d-env', !!env.mapsJsKey, env.mapsJsKey ? 'Env OK' : 'Env ‚úñ'); } catch { ok('d-env', false, 'Env ‚úñ'); }
      ok('d-maps', !!(window.google && window.google.maps), (window.google && window.google.maps) ? 'Maps OK' : 'Maps ‚úñ');
      try { const pl = await fetch('/api/places-nearby?lat=51.5&lng=-0.12&radius=500&type=subway_station').then(r => r.json()); ok('d-pl', pl.status === 'OK' || pl.status === 'ZERO_RESULTS', 'Places ' + (pl.status || '‚úñ')); } catch { ok('d-pl', false, 'Places ‚úñ'); }
      try { const dr = await fetch('/api/directions?origin=51.5074,-0.1278&destination=51.5033,-0.1196&mode=TRANSIT&transitModes=subway|train|tram|bus').then(r => r.json()); ok('d-dir', dr.status === 'OK' || dr.status === 'ZERO_RESULTS', 'Dir ' + (dr.status || '‚úñ')); } catch { ok('d-dir', false, 'Dir ‚úñ'); }
      setTimeout(() => box.remove(), 8000);
    })();
  </script>

  <!-- PWA: register service worker -->
  <script>
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('/sw.js').catch(() => { });
      });
    }
  </script>
</body>

</html>