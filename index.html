<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Myco ‚Äî Cycle + TfL Planner (Google Maps)</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    :root {
      --bg-1: 255 241 242; /* rose-50 */
      --brand: 139 92 246; /* violet-500 */
      --accent: 16 185 129; /* emerald-500 */
      --hot: 249 115 22;   /* orange-500 */
    }
    html, body { height: 100%; }
    body { font-family: Inter, ui-sans-serif, system-ui; background: rgb(var(--bg-1)); }
    #map { height: 100%; min-height: 420px; border-radius: 2rem; overflow: hidden; }
    .blob-wrap { position: fixed; inset: -10% -10% auto -10%; z-index: 0; filter: blur(40px); pointer-events: none; }
    .blob { position: absolute; border-radius: 9999px; opacity: .35; mix-blend: multiply; }
    .b1 { width: 38vmax; height: 38vmax; left: -6vmax; top: -6vmax; background: radial-gradient(closest-side, rgba(var(--brand), .9), rgba(var(--brand), 0)); }
    .b2 { width: 32vmax; height: 32vmax; right: 8vmax; top: -4vmax; background: radial-gradient(closest-side, rgba(var(--accent), .9), rgba(var(--accent), 0)); }
    .b3 { width: 36vmax; height: 36vmax; left: 20vmax; top: 22vmax; background: radial-gradient(closest-side, rgba(var(--hot), .9), rgba(var(--hot), 0)); }
    .glass { backdrop-filter: blur(8px); background: rgba(255, 255, 255, .7); border-radius: 2rem; }
    .btn { @apply inline-flex items-center justify-center gap-2 rounded-full px-5 py-3 text-base font-medium transition shadow-sm active:scale-[.99]; }
    .btn-primary { background: linear-gradient(135deg, rgb(var(--brand)) 0%, rgb(var(--accent)) 100%); color: white; }
    .btn-primary:hover { filter: brightness(0.98); }
    .btn-ghost { @apply border border-white/60 glass; }
    .card { @apply rounded-3xl border border-white/60 glass shadow-lg; }
    .field { @apply w-full rounded-full border border-slate-300/60 px-5 py-3 text-base focus:outline-none focus:ring-4 focus:ring-violet-300/40; }
    .section-title { @apply text-sm font-semibold text-slate-700 uppercase tracking-wide; }
    .chip { display:inline-flex; align-items:center; gap:.4rem; font-size:.75rem; padding:.25rem .6rem; border-radius:999px; border:1px solid rgb(255 255 255 / .8); background:rgb(255 255 255 / .8); }
    /* Pretty slider */
    .slider { -webkit-appearance: none; width: 100%; height: 0.75rem; background: rgba(255,255,255,.8); border-radius: 999px; outline: none; border: 1px solid rgba(148,163,184,.35); }
    .slider::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 1.25rem; height: 1.25rem; border-radius: 999px; background: linear-gradient(135deg, rgb(var(--brand)) 0%, rgb(var(--accent)) 100%); border: 2px solid white; box-shadow: 0 4px 10px rgba(0,0,0,.15); cursor: pointer; }
    .slider::-moz-range-thumb { width: 1.25rem; height: 1.25rem; border-radius: 999px; background: linear-gradient(135deg, rgb(var(--brand)) 0%, rgb(var(--accent)) 100%); border: 2px solid white; box-shadow: 0 4px 10px rgba(0,0,0,.15); cursor: pointer; }
    .value-badge { @apply text-xs px-2 py-0.5 rounded-full bg-white/70 border border-white/80 text-slate-700; }
    /* Corner mycelium mark */
    .corner-mark { position: fixed; right: 14px; bottom: 14px; width: 84px; height: 84px; opacity: .35; pointer-events: none; filter: drop-shadow(0 6px 12px rgba(0,0,0,.12)); }
  </style>
</head>
<body>
  <!-- background blobs -->
  <div class="blob-wrap" aria-hidden="true">
    <div class="blob b1"></div>
    <div class="blob b2"></div>
    <div class="blob b3"></div>
  </div>

  <!-- header -->
  <header class="px-4 sm:px-6 py-3 sticky top-0 z-40">
    <div class="card px-4 py-3 flex items-center gap-2">
      <!-- Mycelium glyph -->
      <span class="inline-flex h-12 w-12 items-center justify-center rounded-full text-white font-bold shadow-md" style="background:linear-gradient(135deg, rgb(var(--hot)) 0%, rgb(var(--accent)) 100%);">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path d="M12 21v-6m0 0c-2.5 0-4.5-2-4.5-4.5S9.5 6 12 6s4.5 2 4.5 4.5S14.5 15 12 15Zm0-9V3m0 6L7 3m5 6 5-6M7.5 10.5 3 9m4.5 1.5L3 15m9 0 4.5 4.5M12 15l-4.5 4.5" stroke="currentColor" stroke-width="1.6" stroke-linecap="round"/>
        </svg>
      </span>
      <h1 class="text-xl font-semibold text-slate-800">Myco</h1>
      <span class="ml-1 text-xs px-2 py-0.5 rounded-full bg-white/70 border border-white/80 text-slate-600">Google</span>
      <div class="ml-auto flex items-center gap-2">
        <input id="apiKey" type="password" placeholder="Google Maps API key" class="hidden sm:block field w-80"/>
        <button id="loadSdkBtn" class="btn btn-ghost">Load Maps</button>
      </div>
    </div>
  </header>

  <!-- main -->
  <main class="max-w-7xl mx-auto w-full gap-4 grid grid-cols-1 lg:grid-cols-[430px_1fr] p-3 sm:p-5">
    <section class="card p-4 space-y-4">
      <div class="grid sm:grid-cols-2 gap-3">
        <div>
          <label class="section-title">Origin</label>
          <div class="flex gap-2">
            <input id="origin" class="field flex-1" placeholder="Address or place"/>
            <button id="useLoc" class="btn btn-ghost shrink-0" title="Use my location">üìç</button>
          </div>
        </div>
        <div>
          <label class="section-title">Destination</label>
          <input id="destination" class="field" placeholder="Where to?"/>
        </div>
      </div>
      <div class="grid grid-cols-1 gap-4">
        <div>
          <div class="flex items-center justify-between">
            <label class="section-title">Max cycling (minutes)</label>
            <span class="value-badge"><span id="cycleVal">10</span> min</span>
          </div>
          <input id="cycleTime" type="range" min="5" max="60" step="5" value="10" class="slider mt-1"/>
          <div class="flex justify-between text-[10px] text-slate-600 mt-1">
            <span>5</span><span>10</span><span>15</span><span>20</span><span>30</span><span>45</span><span>60</span>
          </div>
        </div>
        <div>
          <label class="section-title">Bike speed (km/h)</label>
          <input id="bikeSpeed" type="number" min="8" max="30" step="1" value="16" class="field"/>
        </div>
      </div>
      <div class="flex items-start gap-3 p-3 rounded-full border border-white/60 glass">
        <input id="strictCap" type="checkbox" class="h-5 w-5 rounded-full mt-0.5"/>
        <div class="text-sm">Strict cycling cap ‚Äî ignore bike‚Äëonly if over the cap.</div>
      </div>
      <div class="grid grid-cols-2 gap-2">
        <button id="planBtn" class="btn btn-primary">üöÄ Find route</button>
        <button id="clearBtn" class="btn btn-ghost">Clear</button>
      </div>
      <div id="msg" class="text-sm text-slate-700"></div>
    </section>

    <section class="grid grid-rows-[minmax(420px,1fr)_auto] gap-3">
      <div id="map" class="card"></div>
      <div class="card p-4">
        <div class="flex items-center justify-between">
          <h3 class="text-sm font-semibold mb-2">Best route</h3>
          <div id="fare" class="text-sm"></div>
        </div>
        <div id="summary" class="text-sm"></div>
      </div>
    </section>
  </main>

  <!-- subtle mycelium corner mark -->
  <svg class="corner-mark" viewBox="0 0 200 200" aria-hidden="true">
    <g stroke="#8B5CF6" stroke-width="2" fill="none" opacity="0.55">
      <path d="M100 190 C95 150 95 140 70 120 M100 190 C105 150 110 140 130 120"/>
      <path d="M70 120 C60 110 55 95 45 85 M70 120 C75 95 80 85 90 75"/>
      <path d="M130 120 C140 105 150 95 165 90 M130 120 C122 98 118 90 110 80"/>
      <circle cx="100" cy="190" r="5" fill="#10B981" stroke="white" stroke-width="3"/>
      <circle cx="70" cy="120" r="4" fill="#10B981" stroke="white" stroke-width="2"/>
      <circle cx="130" cy="120" r="4" fill="#10B981" stroke="white" stroke-width="2"/>
      <circle cx="45" cy="85" r="3" fill="#10B981" stroke="white" stroke-width="2"/>
      <circle cx="90" cy="75" r="3" fill="#10B981" stroke="white" stroke-width="2"/>
      <circle cx="165" cy="90" r="3" fill="#10B981" stroke="white" stroke-width="2"/>
      <circle cx="110" cy="80" r="3" fill="#10B981" stroke="white" stroke-width="2"/>
    </g>
  </svg>

  <script>
    // ===== Google SDK loader =====
    let map, placesService, directionsService;
    let originPlace = null, destPlace = null;
    let originMarker, destMarker;
    let polylines = [], stationMarkers = [];

    const el = (id) => document.getElementById(id);
    const msg = (t) => el('msg').innerHTML = t || '';

    const LINE_COLOURS = {
      'Bakerloo':'#B36305','Central':'#E32017','Circle':'#FFD300','District':'#00782A','Hammersmith & City':'#F3A9BB','Jubilee':'#A0A5A9','Metropolitan':'#9B0056','Northern':'#000000','Piccadilly':'#003688','Victoria':'#0098D4','Waterloo & City':'#95CDBA','DLR':'#00A4A7','London Overground':'#EE7C0E','Elizabeth line':'#6950A1','Tram':'#009999','Bus':'#CC0000'
    };

    // Update slider badge live
    (function(){
      const slider = el('cycleTime');
      const out = el('cycleVal');
      const sync = () => { out.textContent = slider.value; };
      slider.addEventListener('input', sync); sync();
    })();

    el('loadSdkBtn').addEventListener('click', async () => {
      let key = el('apiKey').value.trim();
      if (!key) { key = prompt('Enter your Google Maps JavaScript API key (Directions + Places + Geometry):') || ''; el('apiKey').value = key; }
      if (!key) { msg('Please provide a Google Maps API key.'); return; }
      if (window.google && window.google.maps) { msg('Maps SDK already loaded.'); return; }
      await loadGoogleMaps(key);
      initAfterMapsLoad();
    });

    function loadGoogleMaps(key){
      return new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = `https://maps.googleapis.com/maps/api/js?key=${key}&libraries=places,geometry`;
        script.async = true; script.defer = true;
        script.onload = resolve; script.onerror = () => reject(new Error('Failed to load Google Maps SDK'));
        document.head.appendChild(script);
      });
    }

    function initAfterMapsLoad(){
      msg('Maps SDK loaded. You can now search.');
      map = new google.maps.Map(document.getElementById('map'), {
        center: { lat: 51.5074, lng: -0.1278 }, zoom: 11, mapTypeControl:false, streetViewControl:false, fullscreenControl:false,
        styles: [ { featureType: 'poi', stylers: [{ visibility: 'off' }] } ]
      });
      placesService = new google.maps.places.PlacesService(map);
      directionsService = new google.maps.DirectionsService();

      const originInput = el('origin');
      const destInput = el('destination');
      const originAC = new google.maps.places.Autocomplete(originInput, { fields: ["geometry","name","formatted_address"] });
      const destAC   = new google.maps.places.Autocomplete(destInput,   { fields: ["geometry","name","formatted_address"] });

      originAC.addListener('place_changed', () => {
        originPlace = originAC.getPlace();
        if (originPlace?.geometry?.location) { setMarker('origin', originPlace.geometry.location); map.panTo(originPlace.geometry.location); map.setZoom(13); }
      });
      destAC.addListener('place_changed', () => {
        destPlace = destAC.getPlace();
        if (destPlace?.geometry?.location) { setMarker('dest', destPlace.geometry.location); }
      });

      el('useLoc').addEventListener('click', useGeolocation);
      el('planBtn').addEventListener('click', planBestRoute);
      el('clearBtn').addEventListener('click', clearAll);
    }

    function setMarker(kind, latLng){
      const color = kind === 'origin' ? '#34d399' : '#fbbf24';
      const pin = { path: google.maps.SymbolPath.CIRCLE, scale: 10, fillColor: color, fillOpacity: 1, strokeWeight: 3, strokeColor: '#ffffff' };
      if (kind === 'origin') { originMarker?.setMap(null); originMarker = new google.maps.Marker({ position: latLng, map, icon: pin, title:'Origin' }); }
      else { destMarker?.setMap(null); destMarker = new google.maps.Marker({ position: latLng, map, icon: pin, title:'Destination' }); }
    }

    function useGeolocation(){
      if (!navigator.geolocation) { msg('Geolocation not supported.'); return; }
      navigator.geolocation.getCurrentPosition((pos) => {
        const ll = { lat: pos.coords.latitude, lng: pos.coords.longitude };
        originPlace = { geometry: { location: new google.maps.LatLng(ll) }, name: 'My location', formatted_address: 'My location' };
        el('origin').value = 'My location'; setMarker('origin', ll); map.setZoom(14); map.panTo(ll);
      }, (err) => msg('Failed to get location: ' + err.message), { enableHighAccuracy: true, timeout: 10000 });
    }

    function clearAll(){
      originPlace = destPlace = null; el('origin').value = ''; el('destination').value='';
      [originMarker,destMarker].forEach(m=>m?.setMap(null)); originMarker=destMarker=null;
      polylines.forEach(l=>l.setMap(null)); polylines=[];
      stationMarkers.forEach(m=>m.setMap(null)); stationMarkers=[];
      el('summary').innerHTML=''; el('fare').innerHTML=''; msg('');
    }

    // ===== Core planning (Google Directions + Places) =====
    async function planBestRoute(){
      if (!window.google || !window.google.maps) { msg('Load the Maps SDK first.'); return; }
      if (!originPlace?.geometry?.location || !destPlace?.geometry?.location) { msg('Please set both origin and destination.'); return; }

      msg('Planning‚Ä¶');
      polylines.forEach(l=>l.setMap(null)); polylines=[]; stationMarkers.forEach(m=>m.setMap(null)); stationMarkers=[]; el('fare').innerHTML='';

      const maxCycleMin = parseInt(el('cycleTime').value,10);
      const strictCap = el('strictCap').checked;
      const bikeSpeedKmh = parseFloat(el('bikeSpeed').value || '16');
      const maxCycleMeters = Math.round((bikeSpeedKmh * 1000 / 3600) * (maxCycleMin * 60));

      const originLL = originPlace.geometry.location; const destLL = destPlace.geometry.location;

      const [originStations, destStations] = await Promise.all([
        searchStationsNear(originLL, maxCycleMeters, 6),
        searchStationsNear(destLL, maxCycleMeters, 6)
      ]);

      // draw stations
      [...originStations,...destStations].forEach((s,idx)=>{
        const m = new google.maps.Marker({ position: s.location, map, icon: { path: google.maps.SymbolPath.CIRCLE, scale: 6, fillColor: idx < originStations.length ? '#06b6d4' : '#f59e0b', fillOpacity: 1, strokeColor: 'white', strokeWeight: 2 }, title: s.name });
        stationMarkers.push(m);
      });

      const candidates = [];

      // Bike-only
      try {
        const bikeOD = await routeOnce({ origin: originLL, destination: destLL, mode: 'BICYCLING' });
        const tBike = sumDuration(bikeOD);
        const allowBikeOnly = !strictCap || (tBike <= maxCycleMin*60);
        if (allowBikeOnly) candidates.push({ kind:'bike-only', totalSec:tBike, segments:[bikeOD] });
      } catch {}

      // Transit-only
      try {
        const trOD = await routeOnce({ origin: originLL, destination: destLL, mode: 'TRANSIT', transitModes:['SUBWAY','TRAIN','TRAM','BUS'] });
        candidates.push({ kind:'transit-only', totalSec: sumDuration(trOD), segments:[trOD] });
      } catch {}

      // Combos
      for (const a of originStations){
        for (const b of destStations){
          try {
            const seg1 = await routeOnce({ origin: originLL, destination: a.location, mode:'BICYCLING' });
            const seg2 = await routeOnce({ origin: a.location, destination: b.location, mode:'TRANSIT', transitModes:['SUBWAY','TRAIN','TRAM','BUS'] });
            const seg3 = await routeOnce({ origin: b.location, destination: destLL, mode:'BICYCLING' });
            const t1=sumDuration(seg1), t2=sumDuration(seg2), t3=sumDuration(seg3);
            if (t1>maxCycleMin*60 || t3>maxCycleMin*60) continue;
            candidates.push({ kind:'combo', totalSec:t1+t2+t3, parts:{a,b}, segments:[seg1,seg2,seg3] });
          } catch {}
        }
      }

      if (!candidates.length){ msg('No routes found. Try increasing cycling time.'); return; }
      candidates.sort((x,y)=>x.totalSec-y.totalSec);
      const best = candidates[0];
      renderSolution(best);
      msg('');
    }

    function sumDuration(dirResult){
      try { return dirResult.routes[0].legs.reduce((acc,leg)=>acc+(leg.duration?.value||0),0); } catch { return Infinity; }
    }

    function routeOnce({ origin, destination, mode, transitModes }){
      return new Promise((resolve,reject)=>{
        const req = { origin, destination, travelMode: google.maps.TravelMode[mode], provideRouteAlternatives:false };
        if (mode==='TRANSIT' && transitModes){ req.transitOptions = { modes: transitModes.map(k=>google.maps.TransitMode[k]) }; }
        directionsService.route(req, (res,status)=>{ if (status==='OK' && res?.routes?.length) resolve(res); else reject(new Error(status)); });
      });
    }

    function searchStationsNear(ll, radiusMeters, maxCount=6){
      const reqs = [ { location: ll, radius: radiusMeters, type:'subway_station' }, { location: ll, radius: radiusMeters, type:'train_station' } ];
      const found = [];
      return new Promise((resolve)=>{
        let pending=reqs.length;
        reqs.forEach((r)=>{
          placesService.nearbySearch(r, (results,status)=>{
            if (status==='OK' && Array.isArray(results)){
              for (const p of results){ if (!p.geometry?.location) continue; found.push({ placeId:p.place_id, name:p.name, location:p.geometry.location }); }
            }
            if (--pending===0){
              const uniq = Object.values(found.reduce((acc,s)=>{ acc[s.placeId]=s; return acc; },{}));
              uniq.sort((a,b)=> google.maps.geometry ? (google.maps.geometry.spherical.computeDistanceBetween(a.location,ll) - google.maps.geometry.spherical.computeDistanceBetween(b.location,ll)) : 0);
              resolve(uniq.slice(0,maxCount));
            }
          });
        });
      });
    }

    function normaliseLineName(raw, vehicle){
      const r=String(raw||'').trim();
      if (/overground/i.test(r)) return 'London Overground';
      if (/elizabeth/i.test(r)) return 'Elizabeth line';
      if (/dlr/i.test(r)) return 'DLR';
      if (/bakerloo/i.test(r)) return 'Bakerloo';
      if (/central/i.test(r)) return 'Central';
      if (/circle/i.test(r)) return 'Circle';
      if (/district/i.test(r)) return 'District';
      if (/hammersmith/i.test(r)) return 'Hammersmith & City';
      if (/jubilee/i.test(r)) return 'Jubilee';
      if (/metropolitan/i.test(r)) return 'Metropolitan';
      if (/northern/i.test(r)) return 'Northern';
      if (/piccadilly/i.test(r)) return 'Piccadilly';
      if (/victoria/i.test(r)) return 'Victoria';
      if (/waterloo/i.test(r)) return 'Waterloo & City';
      if (/tram/i.test(r)) return 'Tram';
      if (/bus/i.test(vehicle||r)) return 'Bus';
      return r;
    }
    function lineColor(name){ return LINE_COLOURS[normaliseLineName(name)] || '#334155'; }
    function badge(label, color){ return `<span class=\"chip\" style=\"border-color:${color}; background:${color}1a; color:${color}\">${label}</span>`; }

    function renderSolution(sol){
      const summary = el('summary'); summary.innerHTML=''; el('fare').innerHTML='';
      const fmt = (s)=>{ const m=Math.round(s/60); return m<60? `${m} min` : `${Math.floor(m/60)}h ${m%60}m`; };

      // draw polylines
      for (const r of sol.segments){
        const route = r.routes[0];
        const poly = new google.maps.Polyline({ path: google.maps.geometry.encoding.decodePath(route.overview_polyline), strokeColor: r.request.travelMode==='BICYCLING' ? '#10b981' : '#6366f1', strokeOpacity:.95, strokeWeight:7, map });
        polylines.push(poly);
      }
      const bounds = new google.maps.LatLngBounds(); polylines.forEach(pl=>pl.getPath().forEach(pt=>bounds.extend(pt))); if (!bounds.isEmpty()) map.fitBounds(bounds,64);

      // title
      const title = document.createElement('div'); title.className='mb-2'; title.innerHTML = `<div class=\"text-base font-semibold text-slate-800\">${labelForKind(sol)}</div><div class=\"text-sm text-slate-700\">Total time: <span class=\\"font-semibold\\">${fmt(sol.totalSec)}</span></div>`; summary.appendChild(title);

      const list = document.createElement('ol'); list.className='list-decimal pl-5 space-y-3';
      if (sol.kind==='combo'){
        const li1=document.createElement('li'); li1.innerHTML = `<div class=\"font-medium\">Cycle ‚Äî ${fmt(sol.segments[0].routes[0].legs.reduce((a,l)=>a+(l.duration?.value||0),0))}</div><div class=\"text-xs text-slate-600\">to <b>${sol.parts.a.name}</b></div>`; list.appendChild(li1);
        const li2=document.createElement('li'); li2.innerHTML = `<div class=\"font-medium\">TfL Transit ‚Äî ${fmt(sol.segments[1].routes[0].legs.reduce((a,l)=>a+(l.duration?.value||0),0))}</div>`; list.appendChild(li2);
        const li3=document.createElement('li'); li3.innerHTML = `<div class=\"font-medium\">Cycle ‚Äî ${fmt(sol.segments[2].routes[0].legs.reduce((a,l)=>a+(l.duration?.value||0),0))}</div><div class=\"text-xs text-slate-600\">from <b>${sol.parts.b.name}</b> to destination</div>`; list.appendChild(li3);
      } else if (sol.kind==='bike-only'){
        const li=document.createElement('li'); li.innerHTML = `<div class=\"font-medium\">Cycle ‚Äî ${fmt(sol.totalSec)}</div>`; list.appendChild(li);
      } else if (sol.kind==='transit-only'){
        const li=document.createElement('li'); li.innerHTML = `<div class=\"font-medium\">TfL Transit ‚Äî ${fmt(sol.totalSec)}</div>`; list.appendChild(li);
      }
      summary.appendChild(list);

      // transit details + transfers + fare
      const transitDetails=[]; const transfers=[]; let lastLine=null, lastArrStop=null; let shownFareText=null;
      for (const r of sol.segments){
        const isBike = r.request.travelMode==='BICYCLING'; if (isBike) continue;
        const route=r.routes[0]; if (!shownFareText && route.fare?.text) shownFareText = route.fare.text;
        for (const leg of route.legs){
          for (const step of leg.steps){
            const td = step.transit; if (!td) continue;
            const vehicle = td.line?.vehicle?.type || '';
            const rawLine = td.line?.short_name || td.line?.name || vehicle || 'Transit';
            const lineName = normaliseLineName(rawLine, vehicle);
            const color = lineColor(lineName);
            const dep = td.departure_stop?.name || ''; const arr = td.arrival_stop?.name || '';
            const dir = td.headsign ? `towards ${td.headsign}` : '';
            const stops = (typeof td.num_stops==='number') ? ` ‚Ä¢ ${td.num_stops} stops` : '';
            if (lastLine && lastLine!==lineName && lastArrStop){ transfers.push({ at:lastArrStop, from:lastLine, to:lineName }); }
            lastLine=lineName; lastArrStop=arr||dep||lastArrStop;
            transitDetails.push({ html: `${badge(lineName,color)} <b>${dep}</b> ‚Üí <b>${arr}</b> <span class='text-slate-600'>${dir}</span>${stops}` });
          }
        }
      }

      if (shownFareText){ el('fare').innerHTML = `<span class=\"chip\">üí∑ ${shownFareText}</span>`; }

      if (transitDetails.length){
        const block=document.createElement('div'); block.className='mt-3 p-3 rounded-[1.25rem] bg-white/70 border border-white/80';
        const t=document.createElement('div'); t.className='text-sm font-semibold text-slate-800'; t.textContent='Detailed TfL instructions'; block.appendChild(t);
        const ul=document.createElement('ul'); ul.className='text-sm text-slate-800 list-disc pl-5 space-y-1 mt-1';
        transitDetails.forEach(td=>{ const li=document.createElement('li'); li.innerHTML=td.html; ul.appendChild(li); });
        block.appendChild(ul);
        if (transfers.length){
          const row=document.createElement('div'); row.className='mt-3 flex flex-wrap gap-2 items-center';
          row.innerHTML = `<span class=\"text-xs font-semibold text-slate-700\">Transfers:</span> ` + transfers.map(tb => `${badge(tb.from, lineColor(tb.from))} ‚Üí ${badge(tb.to, lineColor(tb.to))} <span class=\"text-slate-600\">@ ${tb.at}</span>`).join(' ');
          block.appendChild(row);
        }
        summary.appendChild(block);
      }
    }

    function labelForKind(sol){
      if (sol.kind==='bike-only') return 'Best: Bike only';
      if (sol.kind==='transit-only') return 'Best: Transit only';
      if (sol.kind==='combo') return 'Best: Cycle ‚Üí TfL ‚Üí Cycle';
      return 'Best route';
    }
  </script>
</body>
</html>
