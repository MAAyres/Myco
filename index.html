<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Myco ‚Äî Cycle + TfL Planner (Google Maps + Serverless)</title>
  <link rel="manifest" href="/manifest.webmanifest">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    :root { --bg-1: 255 241 242; --brand: 139 92 246; --accent: 16 185 129; --hot: 249 115 22; }
    html, body { height: 100%; }
    body { font-family: Inter, ui-sans-serif, system-ui; background: rgb(var(--bg-1)); }
    #map { height: 100%; min-height: 420px; border-radius: 2rem; overflow: hidden; }
    @media (max-width: 640px){ #map { height: 60vh; min-height: 60vh; } }
    .blob-wrap { position: fixed; inset: -10% -10% auto -10%; z-index: 0; filter: blur(40px); pointer-events: none; }
    .blob { position: absolute; border-radius: 9999px; opacity: .35; mix-blend: multiply; }
    .b1 { width: 38vmax; height: 38vmax; left: -6vmax; top: -6vmax; background: radial-gradient(closest-side, rgba(var(--brand), .9), rgba(var(--brand), 0)); }
    .b2 { width: 32vmax; height: 32vmax; right: 8vmax; top: -4vmax; background: radial-gradient(closest-side, rgba(var(--accent), .9), rgba(var(--accent), 0)); }
    .b3 { width: 36vmax; height: 36vmax; left: 20vmax; top: 22vmax; background: radial-gradient(closest-side, rgba(var(--hot), .9), rgba(var(--hot), 0)); }
    .glass { backdrop-filter: blur(8px); background: rgba(255, 255, 255, .7); border-radius: 2rem; }
    .btn { @apply inline-flex items-center justify-center gap-2 rounded-full px-5 py-3 text-base font-medium transition shadow-sm active:scale-[.99]; }
    .btn-primary { background: linear-gradient(135deg, rgb(var(--brand)) 0%, rgb(var(--accent)) 100%); color: white; }
    .btn-ghost { @apply border border-white/60 glass; }
    .card { @apply rounded-3xl border border-white/60 glass shadow-lg; }
    .field { @apply w-full rounded-full border border-slate-300/60 px-5 py-3 text-base focus:outline-none focus:ring-4 focus:ring-violet-300/40; }
    .section-title { @apply text-sm font-semibold text-slate-700 uppercase tracking-wide; }
    .chip { display:inline-flex; align-items:center; gap:.4rem; font-size:.75rem; padding:.25rem .6rem; border-radius:999px; border:1px solid rgb(255 255 255 / .8); background:rgb(255 255 255 / .8); }
    .slider { -webkit-appearance: none; width: 100%; height: 0.75rem; background: rgba(255,255,255,.8); border-radius: 999px; outline: none; border: 1px solid rgba(148,163,184,.35); }
    .slider::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 1.25rem; height: 1.25rem; border-radius: 999px; background: linear-gradient(135deg, rgb(var(--brand)) 0%, rgb(var(--accent)) 100%); border: 2px solid white; box-shadow: 0 4px 10px rgba(0,0,0,.15); cursor: pointer; }
    .slider::-moz-range-thumb { width: 1.25rem; height: 1.25rem; border-radius: 999px; background: linear-gradient(135deg, rgb(var(--brand)) 0%, rgb(var(--accent)) 100%); border: 2px solid white; box-shadow: 0 4px 10px rgba(0,0,0,.15); cursor: pointer; }
    .value-badge { @apply text-xs px-2 py-0.5 rounded-full bg-white/70 border border-white/80 text-slate-700; }
    .corner-mark { position: fixed; right: 14px; bottom: 14px; width: 84px; height: 84px; opacity: .35; pointer-events: none; filter: drop-shadow(0 6px 12px rgba(0,0,0,.12)); }
  </style>
</head>
<body>
  <div class="blob-wrap" aria-hidden="true">
    <div class="blob b1"></div>
    <div class="blob b2"></div>
    <div class="blob b3"></div>
  </div>

  <header class="px-4 sm:px-6 py-3 sticky top-0 z-40">
    <div class="card px-4 py-3 flex items-center gap-2">
      <!-- Myco logo -->
      <div class="h-12 w-12 rounded-full overflow-hidden shadow-md ring-2 ring-white/60">
        <img src="/icons/icon-192.png" alt="Myco" class="h-full w-full object-cover" />
      </div>

      <h1 class="text-xl font-semibold text-slate-800">Myco</h1>
      <span class="ml-1 text-xs px-2 py-0.5 rounded-full bg-white/70 border border-white/80 text-slate-600">Google + Serverless</span>
      <div class="ml-auto text-xs text-slate-600">Keys secured on server ‚Ä¢ Referrer-locked render key</div>
    </div>
  </header>

  <main class="max-w-7xl mx-auto w-full gap-4 grid grid-cols-1 lg:grid-cols-[430px_1fr] p-3 sm:p-5">
    <section class="card p-4 space-y-4">
      <div class="grid sm:grid-cols-2 gap-3">
        <div>
          <label class="section-title">Origin</label>
          <div class="flex gap-2">
            <input id="origin" class="field flex-1" placeholder="Address or place"/>
            <button id="useLoc" class="btn btn-ghost shrink-0" title="Use my location">üìç</button>
          </div>
        </div>
        <div>
          <label class="section-title">Destination</label>
          <input id="destination" class="field" placeholder="Where to?"/>
        </div>
      </div>
      <div class="grid grid-cols-1 gap-4">
        <div>
          <div class="flex items-center justify-between">
            <label class="section-title">Max cycling (minutes)</label>
            <span class="value-badge"><span id="cycleVal">10</span> min</span>
          </div>
          <input id="cycleTime" type="range" min="5" max="60" step="5" value="10" class="slider mt-1"/>
        </div>
        <div>
          <label class="section-title">Bike speed (km/h)</label>
          <input id="bikeSpeed" type="number" min="8" max="30" step="1" value="16" class="field"/>
        </div>
      </div>
      <div class="flex items-start gap-3 p-3 rounded-full border border-white/60 glass">
        <input id="strictCap" type="checkbox" class="h-5 w-5 rounded-full mt-0.5"/>
        <div class="text-sm">Strict cycling cap ‚Äî ignore bike‚Äëonly if over the cap.</div>
      </div>
      <div class="grid grid-cols-2 gap-2">
        <button id="planBtn" class="btn btn-primary">üöÄ Find route</button>
        <button id="clearBtn" class="btn btn-ghost">Clear</button>
      </div>
      <div id="msg" class="text-sm text-slate-700"></div>
    </section>

    <section class="grid grid-rows-[minmax(420px,1fr)_auto] gap-3">
      <div id="map" class="card"></div>
      <div class="card p-4">
        <div class="flex items-center justify-between">
          <h3 class="text-sm font-semibold mb-2">Best route</h3>
          <div id="fare" class="text-sm"></div>
        </div>
        <div id="summary" class="text-sm"></div>
      </div>
    </section>
  </main>

  <svg class="corner-mark" viewBox="0 0 200 200" aria-hidden="true">
    <g stroke="#8B5CF6" stroke-width="2" fill="none" opacity="0.55">
      <path d="M100 190 C95 150 95 140 70 120 M100 190 C105 150 110 140 130 120"/>
      <path d="M70 120 C60 110 55 95 45 85 M70 120 C75 95 80 85 90 75"/>
      <path d="M130 120 C140 105 150 95 165 90 M130 120 C122 98 118 90 110 80"/>
      <circle cx="100" cy="190" r="5" fill="#10B981" stroke="white" stroke-width="3"/>
      <circle cx="70" cy="120" r="4" fill="#10B981" stroke="white" stroke-width="2"/>
      <circle cx="130" cy="120" r="4" fill="#10B981" stroke="white" stroke-width="2"/>
      <circle cx="45" cy="85" r="3" fill="#10B981" stroke="white" stroke-width="2"/>
      <circle cx="90" cy="75" r="3" fill="#10B981" stroke="white" stroke-width="2"/>
      <circle cx="165" cy="90" r="3" fill="#10B981" stroke="white" stroke-width="2"/>
      <circle cx="110" cy="80" r="3" fill="#10B981" stroke="white" stroke-width="2"/>
    </g>
  </svg>

  <script>
    // ===== Globals =====
    let map, directionsLoaded = false;
    let originPlace = null, destPlace = null;
    let originMarker, destMarker;
    let polylines = [], stationMarkers = [];

    const el = (id) => document.getElementById(id);
    const msg = (t) => el('msg').innerHTML = t || '';

    const LINE_COLOURS = {
      'Bakerloo':'#B36305','Central':'#E32017','Circle':'#FFD300','District':'#00782A','Hammersmith & City':'#F3A9BB','Jubilee':'#A0A5A9','Metropolitan':'#9B0056','Northern':'#000000','Piccadilly':'#003688','Victoria':'#0098D4','Waterloo & City':'#95CDBA','DLR':'#00A4A7','London Overground':'#EE7C0E','Elizabeth line':'#6950A1','Tram':'#009999','Bus':'#CC0000'
    };

    // Slider badge
    (function(){ const s=el('cycleTime'), o=el('cycleVal'); const sync=()=>o.textContent=s.value; s.addEventListener('input',sync); sync(); })();

    // Load Maps JS using server-provided public key, then init autocomplete/map
    (async function bootstrap(){
      try {
        const env = await fetch('/api/env').then(r=>r.json()).catch(()=>({ mapsJsKey:null }));
        const key = env.mapsJsKey || null;
        if (!key) { msg('Maps key not configured. Set NEXT_PUBLIC_MAPS_JS_KEY in Vercel and redeploy.'); return; }
        await loadGoogleMaps(key);
        initAfterMapsLoad();
      } catch (e) { msg('Failed to load Maps: '+ e.message); }
    })();

    function loadGoogleMaps(key){
      return new Promise((resolve, reject) => {
        const s = document.createElement('script');
        s.src = `https://maps.googleapis.com/maps/api/js?key=${key}&libraries=places,geometry`;
        s.async = true; s.defer = true;
        s.onload = resolve; s.onerror = () => reject(new Error('Maps SDK load error'));
        document.head.appendChild(s);
      });
    }

    function initAfterMapsLoad(){
      map = new google.maps.Map(document.getElementById('map'), {
        center: { lat: 51.5074, lng: -0.1278 }, zoom: 11, mapTypeControl:false, streetViewControl:false, fullscreenControl:false,
        styles: [ { featureType: 'poi', stylers: [{ visibility: 'off' }] } ]
      });

      const originInput = el('origin');
      const destInput = el('destination');
      const originAC = new google.maps.places.Autocomplete(originInput, { fields: ["geometry","name","formatted_address"] });
      const destAC   = new google.maps.places.Autocomplete(destInput,   { fields: ["geometry","name","formatted_address"] });

      originAC.addListener('place_changed', () => {
        originPlace = originAC.getPlace();
        if (originPlace?.geometry?.location) { setMarker('origin', originPlace.geometry.location); map.panTo(originPlace.geometry.location); map.setZoom(13); }
      });
      destAC.addListener('place_changed', () => {
        destPlace = destAC.getPlace();
        if (destPlace?.geometry?.location) { setMarker('dest', destPlace.geometry.location); }
      });

      el('useLoc').addEventListener('click', useGeolocation);
      el('planBtn').addEventListener('click', planBestRoute);
      el('clearBtn').addEventListener('click', clearAll);
    }

    function setMarker(kind, latLng){
      const color = kind === 'origin' ? '#34d399' : '#fbbf24';
      const pin = { path: google.maps.SymbolPath.CIRCLE, scale: 10, fillColor: color, fillOpacity: 1, strokeWeight: 3, strokeColor: '#ffffff' };
      if (kind === 'origin') { originMarker?.setMap(null); originMarker = new google.maps.Marker({ position: latLng, map, icon: pin, title:'Origin' }); }
      else { destMarker?.setMap(null); destMarker = new google.maps.Marker({ position: latLng, map, icon: pin, title:'Destination' }); }
    }

    function useGeolocation(){
      if (!navigator.geolocation) { msg('Geolocation not supported.'); return; }
      navigator.geolocation.getCurrentPosition((pos) => {
        const ll = { lat: pos.coords.latitude, lng: pos.coords.longitude };
        originPlace = { geometry: { location: new google.maps.LatLng(ll) }, name: 'My location', formatted_address: 'My location' };
        el('origin').value = 'My location'; setMarker('origin', ll); map.setZoom(14); map.panTo(ll);
      }, (err) => msg('Failed to get location: ' + err.message), { enableHighAccuracy: true, timeout: 10000 });
    }

    function clearAll(){
      originPlace = destPlace = null; el('origin').value = ''; el('destination').value='';
      [originMarker,destMarker].forEach(m=>m?.setMap(null)); originMarker=destMarker=null;
      polylines.forEach(l=>l.setMap(null)); polylines=[];
      stationMarkers.forEach(m=>m.setMap(null)); stationMarkers=[];
      el('summary').innerHTML=''; el('fare').innerHTML=''; msg('');
    }

    // ===== Serverless fetchers =====
    async function fetchDirections({ origin, destination, mode, transitModes }){
      const params = new URLSearchParams({ origin, destination, mode });
      if (mode === 'TRANSIT' && transitModes?.length) params.set('transitModes', transitModes.join('|'));
      const r = await fetch(`/api/directions?${params.toString()}`);
      const json = await r.json();
      if (!r.ok || json.status && json.status !== 'OK') {
        const em = json.error_message || json.status || 'Directions error';
        throw new Error(em);
      }
      return json; // Google Directions REST JSON
    }

    async function fetchNearbyStations({ lat, lng, radius }){
      const q1 = new URLSearchParams({ lat, lng, radius: String(radius), type: 'subway_station' }).toString();
      const q2 = new URLSearchParams({ lat, lng, radius: String(radius), type: 'train_station' }).toString();
      const [aRes, bRes] = await Promise.all([
        fetch(`/api/places-nearby?${q1}`),
        fetch(`/api/places-nearby?${q2}`)
      ]);
      const a = await aRes.json(); const b = await bRes.json();
      if ((!aRes.ok || a.status && a.status!=='OK') && (!bRes.ok || b.status && b.status!=='OK')) {
        const em = a?.error_message || b?.error_message || 'Places nearby error';
        throw new Error(em);
      }
      const take = (json) => (json.results||[]).map(p => ({
        id: p.place_id,
        name: p.name,
        location: new google.maps.LatLng(p.geometry.location.lat, p.geometry.location.lng)
      }));
      const all = [...take(a), ...take(b)];
      const dedup = Object.values(all.reduce((acc, s)=>{ acc[s.id]=s; return acc; }, {}));
      const base = new google.maps.LatLng(lat, lng);
      dedup.sort((x,y)=> google.maps.geometry.spherical.computeDistanceBetween(x.location, base) - google.maps.geometry.spherical.computeDistanceBetween(y.location, base));
      return dedup.slice(0,6);
    }

    // ===== Planner using serverless endpoints =====
    async function planBestRoute(){
      if (!originPlace?.geometry?.location || !destPlace?.geometry?.location) { msg('Please set both origin and destination.'); return; }

      msg('Planning‚Ä¶');
      polylines.forEach(l=>l.setMap(null)); polylines=[]; stationMarkers.forEach(m=>m.setMap(null)); stationMarkers=[]; el('fare').innerHTML='';

      const maxCycleMin = parseInt(el('cycleTime').value,10);
      const strictCap = el('strictCap').checked;
      const bikeSpeedKmh = parseFloat(el('bikeSpeed').value || '16');
      const maxCycleMeters = Math.round((bikeSpeedKmh * 1000 / 3600) * (maxCycleMin * 60));

      const originLL = originPlace.geometry.location; const destLL = destPlace.geometry.location;

      let originStations = [], destStations = [];
      try {
        [originStations, destStations] = await Promise.all([
          fetchNearbyStations({ lat: originLL.lat(), lng: originLL.lng(), radius: maxCycleMeters }),
          fetchNearbyStations({ lat: destLL.lat(), lng: destLL.lng(), radius: maxCycleMeters })
        ]);
      } catch (e) {
        msg('Places error: ' + e.message);
      }

      [...originStations,...destStations].forEach((s,idx)=>{
        const m = new google.maps.Marker({ position: s.location, map, icon: { path: google.maps.SymbolPath.CIRCLE, scale: 6, fillColor: idx < originStations.length ? '#06b6d4' : '#f59e0b', fillOpacity: 1, strokeColor: 'white', strokeWeight: 2 }, title: s.name });
        stationMarkers.push(m);
      });

      const candidates = [];
      const str = (ll) => `${ll.lat()},${ll.lng()}`;

      try {
        const bikeOD = await fetchDirections({ origin: str(originLL), destination: str(destLL), mode: 'BICYCLING' });
        const tBike = sumDurationREST(bikeOD);
        const allowBikeOnly = !strictCap || (tBike <= maxCycleMin*60);
        if (allowBikeOnly) candidates.push({ kind:'bike-only', totalSec:tBike, segments:[{ mode:'BICYCLING', res: bikeOD }] });
      } catch (e) { console.warn('Bike-only failed:', e.message); }

      try {
        const trOD = await fetchDirections({ origin: str(originLL), destination: str(destLL), mode: 'TRANSIT', transitModes:['SUBWAY','TRAIN','TRAM','BUS'] });
        candidates.push({ kind:'transit-only', totalSec: sumDurationREST(trOD), segments:[{ mode:'TRANSIT', res: trOD }] });
      } catch (e) { console.warn('Transit-only failed:', e.message); }

      for (const a of originStations){
        for (const b of destStations){
          try {
            const seg1 = await fetchDirections({ origin: str(originLL), destination: `${a.location.lat()},${a.location.lng()}`, mode:'BICYCLING' });
            const seg2 = await fetchDirections({ origin: `${a.location.lat()},${a.location.lng()}`, destination: `${b.location.lat()},${b.location.lng()}`, mode:'TRANSIT', transitModes:['SUBWAY','TRAIN','TRAM','BUS'] });
            const seg3 = await fetchDirections({ origin: `${b.location.lat()},${b.location.lng()}`, destination: str(destLL), mode:'BICYCLING' });
            const t1=sumDurationREST(seg1), t2=sumDurationREST(seg2), t3=sumDurationREST(seg3);
            if (t1>maxCycleMin*60 || t3>maxCycleMin*60) continue;
            candidates.push({ kind:'combo', totalSec:t1+t2+t3, parts:{a,b}, segments:[{mode:'BICYCLING',res:seg1},{mode:'TRANSIT',res:seg2},{mode:'BICYCLING',res:seg3}] });
          } catch (e) { /* skip bad pair */ }
        }
      }

      if (!candidates.length){ msg('No routes found. Check that billing is enabled and both APIs are allowed on GOOGLE_SERVER_KEY.'); return; }
      candidates.sort((x,y)=>x.totalSec-y.totalSec);
      const best = candidates[0];
      renderSolution(best);
      msg('');
    }

    function sumDurationREST(json){
  try {
    if (json.status && json.status !== 'OK') return Infinity;
    const legs = json.routes?.[0]?.legs || [];
    return legs.reduce((acc, leg) => acc + (leg.duration?.value || 0), 0);
  } catch (e) {
    console.warn('sumDurationREST error', e);
    return Infinity;
  }
}

    function renderSolution(sol){
      const summary = el('summary'); summary.innerHTML=''; el('fare').innerHTML='';
      const fmt = (s)=>{ const m=Math.round(s/60); return m<60? `${m} min` : `${Math.floor(m/60)}h ${m%60}m`; };

      // draw polylines
      for (const seg of sol.segments){
        const route = seg.res.routes[0];
        const path = google.maps.geometry.encoding.decodePath(route.overview_polyline.points);
        const color = seg.mode==='BICYCLING' ? '#10b981' : '#6366f1';
        const poly = new google.maps.Polyline({ path, strokeColor: color, strokeOpacity:.95, strokeWeight:7, map });
        polylines.push(poly);
      }
      const bounds = new google.maps.LatLngBounds(); polylines.forEach(pl=>pl.getPath().forEach(pt=>bounds.extend(pt))); if (!bounds.isEmpty()) map.fitBounds(bounds,64);

      // title
      const title = document.createElement('div'); title.className='mb-2'; title.innerHTML = `<div class="text-base font-semibold text-slate-800">${labelForKind(sol)}</div><div class="text-sm text-slate-700">Total time: <span class=\"font-semibold\">${fmt(sol.totalSec)}</span></div>`; summary.appendChild(title);

      const list = document.createElement('ol'); list.className='list-decimal pl-5 space-y-3';
      if (sol.kind==='combo'){
        const li1=document.createElement('li'); li1.innerHTML = `<div class=\"font-medium\">Cycle ‚Äî ${fmt(sumDurationREST(sol.segments[0].res))}</div><div class=\"text-xs text-slate-600\">to <b>${sol.parts.a.name}</b></div>`; list.appendChild(li1);
        const li2=document.createElement('li'); li2.innerHTML = `<div class=\"font-medium\">TfL Transit ‚Äî ${fmt(sumDurationREST(sol.segments[1].res))}</div>`; list.appendChild(li2);
        const li3=document.createElement('li'); li3.innerHTML = `<div class=\"font-medium\">Cycle ‚Äî ${fmt(sumDurationREST(sol.segments[2].res))}</div><div class=\"text-xs text-slate-600\">from <b>${sol.parts.b.name}</b> to destination</div>`; list.appendChild(li3);
      } else if (sol.kind==='bike-only'){
        const li=document.createElement('li'); li.innerHTML = `<div class=\"font-medium\">Cycle ‚Äî ${fmt(sol.totalSec)}</div>`; list.appendChild(li);
      } else if (sol.kind==='transit-only'){
        const li=document.createElement('li'); li.innerHTML = `<div class=\"font-medium\">TfL Transit ‚Äî ${fmt(sol.totalSec)}</div>`; list.appendChild(li);
      }
      summary.appendChild(list);

      // transit details + transfers + fare
      const transitDetails=[]; const transfers=[]; let lastLine=null, lastArrStop=null; let shownFareText=null;
      for (const seg of sol.segments){
        if (seg.mode==='BICYCLING') continue;
        const route = seg.res.routes[0];
        if (!shownFareText && route.fare?.text) shownFareText = route.fare.text;
        for (const leg of route.legs){
          for (const step of leg.steps){
            const td = step.transit_details; if (!td) continue;
            const vehicle = td.line?.vehicle?.type || '';
            const rawLine = td.line?.short_name || td.line?.name || vehicle || 'Transit';
            const lineName = normaliseLineName(rawLine, vehicle);
            const color = LINE_COLOURS[lineName] || '#334155';
            const dep = td.departure_stop?.name || ''; const arr = td.arrival_stop?.name || '';
            const dir = td.headsign ? `towards ${td.headsign}` : '';
            const stops = (typeof td.num_stops==='number') ? ` ‚Ä¢ ${td.num_stops} stops` : '';
            if (lastLine && lastLine!==lineName && lastArrStop){ transfers.push({ at:lastArrStop, from:lastLine, to:lineName }); }
            lastLine=lineName; lastArrStop=arr||dep||lastArrStop;
            transitDetails.push({ html: `${badge(lineName,color)} <b>${dep}</b> ‚Üí <b>${arr}</b> <span class='text-slate-600'>${dir}</span>${stops}` });
          }
        }
      }

      if (shownFareText){ el('fare').innerHTML = `<span class=\"chip\">üí∑ ${shownFareText}</span>`; }

      if (transitDetails.length){
        const block=document.createElement('div'); block.className='mt-3 p-3 rounded-[1.25rem] bg-white/70 border border-white/80';
        const t=document.createElement('div'); t.className='text-sm font-semibold text-slate-800'; t.textContent='Detailed TfL instructions'; block.appendChild(t);
        const ul=document.createElement('ul'); ul.className='text-sm text-slate-800 list-disc pl-5 space-y-1 mt-1';
        transitDetails.forEach(td=>{ const li=document.createElement('li'); li.innerHTML=td.html; ul.appendChild(li); });
        block.appendChild(ul);
        if (transfers.length){
          const row=document.createElement('div'); row.className='mt-3 flex flex-wrap gap-2 items-center';
          row.innerHTML = `<span class=\"text-xs font-semibold text-slate-700\">Transfers:</span> ` + transfers.map(tb => `${badge(tb.from, LINE_COLOURS[tb.from]||'#334155')} ‚Üí ${badge(tb.to, LINE_COLOURS[tb.to]||'#334155')} <span class=\"text-slate-600\">@ ${tb.at}</span>`).join(' ');
          block.appendChild(row);
        }
        summary.appendChild(block);
      }
    }

    function normaliseLineName(raw, vehicle){
      const r=String(raw||'').trim();
      if (/overground/i.test(r)) return 'London Overground';
      if (/elizabeth/i.test(r)) return 'Elizabeth line';
      if (/dlr/i.test(r)) return 'DLR';
      if (/bakerloo/i.test(r)) return 'Bakerloo';
      if (/central/i.test(r)) return 'Central';
      if (/circle/i.test(r)) return 'Circle';
      if (/district/i.test(r)) return 'District';
      if (/hammersmith/i.test(r)) return 'Hammersmith & City';
      if (/jubilee/i.test(r)) return 'Jubilee';
      if (/metropolitan/i.test(r)) return 'Metropolitan';
      if (/northern/i.test(r)) return 'Northern';
      if (/piccadilly/i.test(r)) return 'Piccadilly';
      if (/victoria/i.test(r)) return 'Victoria';
      if (/waterloo/i.test(r)) return 'Waterloo & City';
      if (/tram/i.test(r)) return 'Tram';
      if (/bus/i.test(vehicle||r)) return 'Bus';
      return r;
    }
    function badge(label, color){ return `<span class=\"chip\" style=\"border-color:${color}; background:${color}1a; color:${color}\">${label}</span>`; }
    function labelForKind(sol){ if (sol.kind==='bike-only') return 'Best: Bike only'; if (sol.kind==='transit-only') return 'Best: Transit only'; if (sol.kind==='combo') return 'Best: Cycle ‚Üí TfL ‚Üí Cycle'; return 'Best route'; }
  </script>
  <script>
    // PWA: register service worker if available
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('/sw.js').catch(()=>{});
      });
    }
  </script>
</body>
</html>
